<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Deciduous - Security Decision Tree Generator</title>
    <script src="https://cdn.jsdelivr.net/npm/@hpcc-js/wasm/dist/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/components/prism-yaml.min.js"></script>
    <link rel="shortcut icon" href="./favicon.ico" type="image/x-icon" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Josefin+Sans&display=swap" rel="stylesheet"> 
    <style type="text/css">
        body, html {
            padding: 0;
            margin: 0;
            overflow: hidden;
            font-family: "Helvetica Neue", Helvetica, arial, sans-serif;
        }
        a {
            color: #1B2CC1;
        }
        a:visited {
            color: #FF499B;
        } 
        #inputSource, #highlighting {
            position: absolute;
            width: 40%;
            height: 100vh;
            margin: 0;
            font-size: 12pt;
            padding: 20px;
            line-height: 20px;
            box-sizing: border-box;
            overflow: auto;
            white-space: pre;
            text-size-adjust: none;
        }
        #inputSource {
            resize: none;
            border: medium none;
            appearance: none;
            -moz-appearance: none;
            -webkit-appearance: none;
            outline: 0;
            border-right: 1px solid silver;
            z-index: 1;
            color: transparent;
            background: transparent;
            caret-color: black;
        }
        #highlighting {
            z-index: 0;
        }
        #inputSource, code {
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
        }
        code {
            padding: 0;
        }
        #errorTarget {
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
        }
        .contentArea {
            position: absolute;
            left: 40%;
            width: 60%;
            height: 100vh;
            overflow: auto;
            font-family: 'Josefin Sans', sans-serif;
        }
        .right-header {
            display: flex;
            width: 100%;
            height: auto;
        }
        .logo {
            margin-right: 1em;
            margin-bottom: 1em;
        }
        .downloadWrapper {
            padding: 5px;
            flex:  1;
        }
        #downloadLink, #downloadSvgLink {
            float: right;
            top: 0;
            margin: 5px;
        }
        #renderTarget {
            display: inline-block;
            position: relative;
            width: 100%;
            padding-bottom: 100%;
            vertical-align: top;
        }
        svg {
            display: inline-block;
            position: absolute;
            top: 0;
            left: 0;
        }
        .copyright {
            text-align: center;
        }
        #highlighting {
            color: grey;
        }
        #highlighting .punctuation {
            color: grey;
        }
        #highlighting .attacks, #highlighting .attack {
            color: #ff1c82;
        }
        #highlighting .mitigations, #highlighting .mitigation {
            color: #2b56b5;
        }
        #highlighting .facts, #highlighting .fact {
            color: #1b0533;
        }
        #highlighting .goals, #highlighting .goal {
            color: #5f00c2;
        }
        #highlighting .comment {
        }
        @media print {
            .logo {
                position: absolute;
                left: 0;
                top: 0;
            }
            .contentArea {
                position: absolute;
                width: 100%;
                height: auto;
                overflow: visible;
            }
            svg {
                position:fixed; 
                top:0; 
                bottom:0; 
                left:0; 
                right:0;
                width: 100%;
                height: 100%;
            }
            #inputSource {
                display: none;
            }
            #inputHighlighted {
                display:  none;
            }
            .downloadWrapper {
                display: none;
            }
            .copyright {
                position: fixed;
                bottom: 0;

        }
    </style>
</head>

<body>
    <textarea id="inputSource" spellcheck="false">
title: Attack Tree for S3 Bucket with Video Recordings

facts:
- wayback: API cache (e.g. Wayback Machine)
  from:
  - reality: '#yolosec'
- public_bucket: S3 bucket set to public
  from:
  - bucket_search: '#yolosec'
- subsystem_with_access: Subsystem with access to bucket data
  from:
  - compromise_user_creds

attacks:
- bucket_search: AWS public buckets search
  from:
  - disallow_crawling
- brute_force:
  from:
  - private_bucket
- phishing:
  from:
  - private_bucket
  - internal_only_bucket:
    backwards: true
  - access_control_server_side:
    backwards: true
- compromise_user_creds: Compromise user credentials
  from:
  - brute_force
  - phishing
- analyze_web_client: Manually analyze web client for access control misconfig
  from:
  - lock_down_acls
- compromise_admin_creds: Compromise admin creds
  from:
  - phishing
- compromise_aws_creds: Compromise AWS admin creds
  from:
  - phishing
- intercept_2fa: Intercept 2FA
  from:
  - 2fa
- ssh_to_public_machine: SSH to an accessible machine
  from:
  - compromise_admin_creds: '#yolosec'
  - compromise_aws_creds:
  - intercept_2fa
- lateral_movement_to_machine_with_access: Lateral movement to machine with access to target bucket
  from:
  - ip_allowlist_for_ssh
- compromise_presigned: Compromise presigned URLs
  from:
  - phishing
- compromise_quickly: Compromise URL within N time period
  from:
  - short_lived_presigning
- recon_on_s3: Recon on S3 buckets
  from:
  - private_bucket
  - disallow_bucket_urls:
    backwards: true
  - 2fa:
    backwards: true
- find_systems_with_access: Find systems with R/W access to target bucket
  from:
  - recon_on_s3: '#yolosec'
- exploit_known_vulns: Exploit known 3rd party library vulns
  from:
  - find_systems_with_access
- buy_0day:
  from:
  - vuln_scanning
- discover_0day: Manual discovery of 0day
  from:
  - vuln_scanning
- exploit_vulns: Exploit vulns
  from:
  - buy_0day
  - discover_0day
- aws_0day: 0day in AWS multitenant systems
  from:
  - ips
- supply_chain_backdoor: Supply chain compromise (backdoor)
  from:
  - single_tenant_hsm

mitigations:
- disallow_crawling: Disallow crawling on site maps
  from:
  - reality
- private_bucket: Auth required / ACLs (private bucket)
  from:
  - reality
- lock_down_acls: Lock down web client with creds / ACLs
  from:
  - subsystem_with_access
- access_control_server_side: Perform all access control server side
  from:
  - analyze_web_client
- 2fa: 2FA
  from:
  - compromise_admin_creds: '#yolosec'
  - compromise_aws_creds
- ip_allowlist_for_ssh: IP allowlist for SSH
  from:
  - ssh_to_public_machine
- short_lived_presigning: Make URL short lived
  from:
  - compromise_presigned
- disallow_bucket_urls: Disallow the use of URLs to access buckets
  from:
  - compromise_quickly
- vuln_scanning: 3rd party library checking / vuln scanning
  from:
  - exploit_known_vulns
- ips: Exploit prevention / detection
  from:
  - exploit_vulns
- single_tenant_hsm: Use single tenant AWS HSM
  from:
  - aws_0day:
    implemented: false
- internal_only_bucket: No public system has R/W access (internal only)
  from:
  - find_systems_with_access

goals:
- s3_asset: Access video recordings in S3 bucket (attackers win)
  from:
  - wayback: '#yolosec'
  - public_bucket
  - subsystem_with_access
  - analyze_web_client
  - lateral_movement_to_machine_with_access
  - compromise_presigned
  - compromise_quickly
  - exploit_vulns
  - aws_0day
  - supply_chain_backdoor
- company_bank_account: Access company bank account
  from:
  - intercept_2fa

# filter can be used to show only paths that flow through specific nodes
filter:
- s3_asset
</textarea>
<pre id="highlighting" aria-hidden="true"><code class="language-yaml" id="inputHighlighted"></code></pre>
    <div class="contentArea">
        <div class="right-header">
            <div class="logo">
                <img src="./deciduous-logo.png" alt="Deciduous logo" height="75" width="198">
            </div>
            <div class="downloadWrapper">
                <p>Inspired by and with example taken from Kelly Shortridge's <a href="https://swagitda.com/blog/posts/security-decision-trees-with-graphviz/">Creating Security Decision Trees With Graphviz</a></p>
                <a id="downloadLink" download="decision-tree.dot">Download .dot</a>
                <a id="downloadSvgLink" download="decision-tree.svg">Download .svg</a>
            </div>
        </div>
        <div id="errorTarget">JavaScript is required</div>
        <div id="renderTarget"></div>
        <p class="copyright">&copy; Copyright 2021 Ryan Petrich & Kelly Shortridge</p>
    </div>
    <script>
        function wordwrap(text, limit) {
            text = String(text);
            if (text.indexOf("\n") != -1) {
                return text;
            }
            const split = text.split(" ");
            let all = [];
            let current = [];
            let currentLength = 0;
            for (let i = 0; i < split.length; i++) {
                const line = split[i];
                if (currentLength == 0 || (currentLength + line.length < limit && line[0] != "(")) {
                    current.push(line);
                    currentLength += line.length;
                } else {
                    all.push(current.join(" "));
                    current = [line];
                    currentLength = line.length;
                }
            }
            all.push(current.join(" "));
            return all.join("\n");
        }
        function mangleName(name) {
            if (/^[A-Za-z]\w*$/.test(name)) {
                return name;
            }
            return JSON.stringify(name);
        }
        function line(name, properties) {
            const entries = Object.entries(properties);
            if (entries.length == 0) {
                return name;
            }
            return name + " [ " + entries.map(([key, value]) => `${key}=${JSON.stringify(value)}`).join(" ") + " ]";
        }
        function parseFrom(raw) {
            if (typeof raw == "object") {
                const [fromName, label] = Object.entries(raw)[0];
                return [fromName, label, raw]
            }
            return [String(raw), null, {}];
        }
        const themes = {
            "classic": {
                "edge": "#2B303A",
                "edge-text": "#DB2955",
                "backwards-edge": "#7692FF",
                "reality-fill": "#2B303A",
                "reality-text": "#FFFFFF",
                "fact-fill": "#C6CCD2",
                "attack-fill": "#ED96AC",
                "mitigation-fill": "#ABD2FA",
                "goal-fill": "#DB2955",
                "goal-text": "#FFFFFF",
            },
            "default": {
                "edge": "#2B303A",
                "edge-text": "#010065",
                "backwards-edge": "#7692FF",
                "reality-fill": "#272727",
                "reality-text": "#FFFFFF",
                "fact-fill": "#D2D5DD",
                "attack-fill": "#ffa6d5",
                "mitigation-fill": "#B9D6F2",
                "goal-fill": "#5f00c2",
                "goal-text": "#FFFFFF",
            },
        }
        function convertToDot(yaml) {
            const parsed = jsyaml.load(yaml);
            const font = 'Arial'
            const theme = themes[Object.hasOwnProperty.call(themes, parsed.theme) ? parsed.theme : "default"];
            const header = `// Generated from https://swagitda.com/deciduous/
digraph {
    // base graph styling
    rankdir="TB";
    splines=true;
    overlap=false;
    nodesep="0.2";
    ranksep="0.4";
    label=${JSON.stringify(String(parsed.title))};
    labelloc="t";
    fontname=${JSON.stringify(font)};
    node [ shape="plaintext" style="filled, rounded" fontname=${JSON.stringify(font)} margin=0.2 ]
    edge [ fontname=${JSON.stringify(font)} fontsize=12 color="${theme["edge"]}" ]

    // is reality a hologram?
    reality [ label="Reality" fillcolor="${theme["reality-fill"]}" fontcolor="${theme["reality-text"]}" ]

`;
            const goals = parsed.goals || [];
            const facts = parsed.facts || [];
            const attacks = parsed.attacks || [];
            const mitigations = parsed.mitigations || [];
            const filter = parsed.filter || [];
            const subgraphs = [];
            const forwards = {};
            const forwardsAll = {};
            const backwards = {};
            const allNodes = [...facts, ...attacks, ...mitigations, ...goals];
            const types = {};
            for (const node of allNodes) {
                const [toName] = Object.entries(node)[0];
                const fromNames = backwards[toName] || (backwards[toName] = []);
                if (node.from) {
                    for (const from of node.from) {
                        const [fromName, label, props] = parseFrom(from);
                        if (!from.backwards && !from.ungrouped) {
                            const toNames = forwards[fromName] || (forwards[fromName] = []);
                            toNames.push(toName);
                            fromNames.push(fromName);
                        }
                        const toNames = forwardsAll[fromName] || (forwardsAll[fromName] = []);
                        toNames.push(toName);
                    }
                }
            }
            function anyDominates(forwards, d, n) {
                // search to see if any nodes in d dominate n
                // nodes dominate themselves
                const search = [];
                const added = {};
                for (const other of d) {
                    added[other] = true;
                    search.push(other);
                }
                while ((d = search.shift()) !== undefined) {
                    if (d === n) {
                        return true;
                    }
                    const others = forwards[d];
                    if (others !== undefined) {
                        for (const other of others) {
                            if (!Object.hasOwnProperty.call(added, other)) {
                                added[other] = true;
                                search.push(other);
                            }
                        }
                    }
                }
                return false;
            }
            function shouldShow(n) {
                if (filter.length == 0 || anyDominates(forwardsAll, filter, n)) {
                    return true;
                }
                const arrayN = [n];
                return filter.find(other => anyDominates(forwardsAll, arrayN, other));
            }
            function defaultLabelForName(name) {
                return name.replace(/_/g, " ").replace(/^[a-z]/, c => c.toUpperCase());
            }
            function nodes(type, values, properties) {
                const result = [];
                for (const value of values) {
                    const [name, label] = Object.entries(value)[0];
                    types[name] = type;
                    if (shouldShow(name)) {
                        result.push(line(mangleName(name), {
                            label: wordwrap(label === null ? defaultLabelForName(name) : label, 18),
                            ...properties,
                        }));
                    }
                }
                return result;
            }
            const allNodeLines = [
                `// facts`,
                ...nodes("fact", facts, {
                    fillcolor: theme["fact-fill"],
                }),
                `// attacks`,
                ...nodes("attack", attacks, {
                    fillcolor: theme["attack-fill"],
                }),
                `// mitigations`,
                ...nodes("mitigation", mitigations, {
                    fillcolor: theme["mitigation-fill"],
                }),
                `// goals`,
                ...nodes("goal", goals, {
                    fillcolor: theme["goal-fill"],
                    fontcolor: theme["goal-text"],
                })
            ];
            function edges(entries, properties) {
                return entries.reduce((edges, value) => {
                    const [name] = Object.entries(value)[0];
                    if (!shouldShow(name)) {
                        return edges;
                    }
                    (value.from || []).forEach((from) => {
                        const [fromName, label, fromProps] = parseFrom(from);
                        if (!shouldShow(fromName)) {
                            return;
                        }
                        const props = {
                            ...properties,
                        };
                        if (label !== null) {
                            props.xlabel = wordwrap(label, 20);
                            props.fontcolor = theme["edge-text"];
                        }
                        if (typeof fromProps.implemented == "boolean" && !fromProps.implemented) {
                            props.style = "dotted";
                        }
                        if (fromProps.backwards) {
                            props.style = "dotted";
                            props.color = theme["backwards-edge"];
                            props.weight = "0";
                        }
                        edges.push(line(`${mangleName(fromName)} -> ${mangleName(name)}`, props));
                    });
                    return edges;
                }, []);
            }
            const allEdgeLines = [...edges(goals, {}), ...edges(attacks, {}), ...edges(mitigations, {}), ...edges(facts, {})];
            const goalNames = goals.map((goal) => {
                const [goalName] = Object.entries(goal)[0];
                return goalName;
            });
            for (const [fromName, toNames] of Object.entries(forwards)) {
                if (!shouldShow(fromName)) {
                    continue;
                }
                const copy = toNames.concat();
                const filteredToNames = [];
                for (let i = 0; i < toNames.length; i++) {
                    copy.splice(i, 1);
                    if (!anyDominates(forwards, copy, toNames[i]) && goalNames.indexOf(toNames[i]) == -1 && shouldShow(toNames[i])) {
                        filteredToNames.push(toNames[i]);
                    }
                    copy.splice(i, 0, toNames[i]);
                }
                if (filteredToNames.length > 1) {
                    subgraphs.push(`    subgraph ${mangleName(fromName)}_order {
        rank=same;
        ${filteredToNames.map(toName => mangleName(toName) + ";").join("\n        ")}
    }
    ${line(filteredToNames.map(mangleName).join(" -> "), { style: "invis" })}`);
                }
            }
            const shownGoals = goalNames.filter(shouldShow);
            if (shownGoals > 1) {

                subgraphs.push(`    subgraph goal_order {
        rank=same;
        ${shownGoals.map(goalName => mangleName(goalName) + ";").join("\n        ")}
    }`);
                subgraphs.push("    " + line(shownGoals.join(" -> "), { style: "invis" }));
            }
            subgraphs.push(`    { rank=min; reality; }`);
            for (const node of allNodes) {
                const [toName] = Object.entries(node)[0];
                if (shouldShow(toName) && !forwards[toName] && shownGoals.indexOf(toName) === -1) {
                    for (const goalName of shownGoals) {
                        subgraphs.push("    " + line(mangleName(toName) + " -> " + mangleName(goalName), { style: "invis", weight: 0 }));
                    }
                }
            }
            subgraphs.push(`    { rank=max; ${shownGoals.map(goalName => mangleName(goalName) + "; ").join("")}}`);
            const footer = "\n\n}\n";
            return [header + "    " + allNodeLines.join("\n    ") + "\n\n    " + allEdgeLines.join("\n    ") + "\n\n    // subgraphs to give proper layout\n" + subgraphs.join("\n\n")  + footer, parsed.title, types];
        }
        const renderTarget = document.getElementById("renderTarget");
        const errorTarget = document.getElementById("errorTarget");
        const inputSource = document.getElementById("inputSource");
        const downloadLink = document.getElementById("downloadLink");
        const downloadSvgLink = document.getElementById("downloadSvgLink");
        const inputHighlighted = document.getElementById("inputHighlighted");
        const highlighting = document.getElementById("highlighting");
        function syncScroll() {
            highlighting.scrollTop = inputSource.scrollTop;
            highlighting.scrollLeft = inputSource.scrollLeft;
        }
        window["@hpcc-js/wasm"].graphvizSync().then(graphviz => {
            let lastInput = "";
            let lastObjectURL = "";
            let lastSvgObjectURL = "";
            function rerender() {
                syncScroll();
                const newInput = inputSource.value;
                if (newInput != lastInput) {
                    lastInput = newInput;
                    inputHighlighted.innerHTML = Prism.highlight(newInput[newInput.length-1] == "\n" ? newInput + " " : newInput, Prism.languages.yaml, "yaml");
                    try {
                        const [dot, title, types] = convertToDot(newInput);
                        types["attacks"] = "attacks";
                        types["mitigations"] = "mitigations";
                        types["goals"] = "goals";
                        types["facts"] = "facts";
                        for (const element of inputHighlighted.childNodes) {
                            if (element.nodeType === 3) {
                                const text = element.nodeValue.trim();
                                if (Object.hasOwnProperty.call(types, text)) {
                                    const span = document.createElement("span");
                                    span.className = types[text];
                                    inputHighlighted.replaceChild(span, element);
                                    span.appendChild(element);
                                }
                            } else if (element.nodeType === 1) {
                                const text = element.innerText;
                                if (Object.hasOwnProperty.call(types, text)) {
                                    element.className += " " + types[text];
                                }
                            }
                        }
                        const highlightedHeight = inputHighlighted.getBoundingClientRect().height;
                        const inputHeight = inputSource.scrollHeight;
                        if (highlightedHeight > inputHeight) {
                            // line height hack for Firefox+Windows
                            highlighting.style.lineHeight = "19px";
                        }
                        // console.log(dot);
                        document.title = `Deciduous - Security Decision Tree Generator (${title})`;
                        const svg = graphviz.layout(dot, "svg", "dot");
                        renderTarget.innerHTML = svg;
                        const svgElement = renderTarget.querySelector("svg");
                        if (svgElement) {
                            const scale = 0.75;
                            svgElement.setAttribute("width", parseInt(svgElement.getAttribute("width"), 10) * scale + "pt");
                            svgElement.setAttribute("height", parseInt(svgElement.getAttribute("height"), 10) * scale + "pt");
                        }
                        if (window.File && URL.createObjectURL) {
                            const file = new File([dot], "graph.dot", {
                                "type": "text/vnd.graphviz",
                            });
                            downloadLink.download = title + ".dot";
                            const newObjectURL = URL.createObjectURL(file);
                            downloadLink.href = newObjectURL;
                            if (lastObjectURL != "") {
                                URL.revokeObjectURL(lastObjectURL);
                            }
                            lastObjectURL = newObjectURL;
                            const svgFile = new File([svg], "graph.svg", {
                                "type": "image/svg+xml",
                            });
                            downloadSvgLink.download = title + ".svg";
                            const newSvgObjectURL = URL.createObjectURL(svgFile);
                            downloadSvgLink.href = newSvgObjectURL;
                            if (lastSvgObjectURL != "") {
                                URL.revokeObjectURL(lastSvgObjectURL);
                            }
                            lastSvgObjectURL = newSvgObjectURL;
                        }
                        for (const title of renderTarget.querySelectorAll("title")) {
                            title.parentNode.style.cursor = "pointer";
                            title.parentNode.addEventListener("click", () => {
                                const node = title.textContent;
                                const index = lastInput.indexOf("\n- " + node);
                                if (index != -1) {
                                    inputSource.blur();
                                    inputSource.selectionEnd = inputSource.selectionStart = index + 3;
                                    inputSource.focus();
                                    inputSource.selectionEnd = index + 3 + node.length;
                                    syncScroll();
                                    setTimeout(syncScroll, 0);
                                }
                            }, false);
                        }
                        errorTarget.innerText = "";
                    } catch (e) {
                        errorTarget.innerText = String(e);
                    }
                }
            }
            inputSource.addEventListener("change", rerender, false);
            inputSource.addEventListener("input", rerender, false);
            inputSource.addEventListener("scroll", syncScroll, false);
            inputSource.addEventListener("select", syncScroll, false);
            inputSource.addEventListener("wheel", syncScroll, false);
            inputSource.addEventListener("focus", syncScroll, false);
            inputSource.addEventListener("blur", syncScroll, false);
            inputSource.addEventListener("keydown", syncScroll, false);
            inputSource.addEventListener("keyup", syncScroll, false);
            rerender();
        });
    </script>

</body>

</html>